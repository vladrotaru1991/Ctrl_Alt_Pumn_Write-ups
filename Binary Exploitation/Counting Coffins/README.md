## TL;DR

Send 32 filler bytes + \x01 -> Profit

## Context

The funeral home’s registration kiosk is old, creaky, and terribly miscounted. When you register, the clerk asks for your name — but one extra character in the wrong place can change everything. Inspect the program, find the off-by-one that lets a single byte flip the clerk’s privilege bit, and claim what it guards. Quiet now — the coffins are listening.

Provided files: coffin-challenge-src.tar

Hint 1: The program reads 33 bytes into a 32-byte name buffer. Try writing exactly one extra byte after the name.

## Recon

Read the code in coffin.c. Try to remember C from college, get a little nostalgia
Notice that the name var has 32 bytes, but the read function, reads 33 bytes
Figure out how to compile the source (haven't touched C in 15 years)
Seems that easiest way with our setup is to use Linux.
Install build-eseential to be able to run "gcc coffin.c flag_stub.c -o coffin"
Figure out how we can pass 33 bytes to the executable, and force 33rd byte to be 1.
Test it on local compilation. It works.
Test it on provided compilation, it also works.

## Vulnerability / Idea

Read function reads 33 bytes, even though the name only has 32. The extra byte is stored in user.is_admin

## Exploitation Steps (Reproducible)

printf 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\001' | ./release/coffin (in Linux)
Find flag: rtech{Count_Your_Ghosts_Wisely}
